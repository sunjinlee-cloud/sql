--제약 조건: 컬럼에 원하는 형식의 데이터만 입력할 수 있도록 한다.
--primary key : 고유키, 중복 및 NULL 불가, 테이블에서 단 한개의 컬럼만 PK임
--UNIQUE : 중복 불가, NULL값은 허용
--NOT NULL : NULL 입력 불가
--FOREIGN KEY: 참조하는 테이블의 PK 혹은 NULL값만 입력 가능
--CHECK : 컬럼에 들어가는 값에 대한 제한

--명령문이나 마우스로 확인 가능
SELECT * FROM USER_CONSTRAINTS;

--열 레벨에서의 제약 조건
CREATE TABLE DEPTS(
    DEPT_NO NUMBER(2) CONSTRAINT DEPTS_DEPT_NO_PK PRIMARY KEY,
    DEPT_NAME VARCHAR2(30) CONSTRAINT DEPTS_DEPT_NAME NOT NULL,
    DEPT_DATE DATE DEFAULT SYSDATE, --값이 들어가지 않을 때 자동으로 넣어주는 값
    DEPT_PHONE VARCHAR2(30) CONSTRAINT DEPTS_DEPT_PHONE UNIQUE,
    DEPT_GENDER CHAR(1) CONSTRAINT DEPTS_DEPT_GENDER CHECK(DEPT_GENDER IN ('M', 'F')),
    LOCA_ID NUMBER(4) CONSTRAINT DEPTS_LOCA_ID_KF REFERENCES LOCATIONS(LOCATION_ID)
);
DROP TABLE DEPTS;
--CONSTRAINT 는 생략가능
CREATE TABLE DEPTS(
    DEPT_NO NUMBER(2) PRIMARY KEY,
    DEPT_NAME VARCHAR2(30) NOT NULL,
    DEPT_DATE DATE DEFAULT SYSDATE, --값이 들어가지 않을 때 자동으로 넣어주는 값
    DEPT_PHONE VARCHAR2(30)  UNIQUE,
    DEPT_GENDER CHAR(1) CHECK(DEPT_GENDER IN ('M', 'F')),
    LOCA_ID NUMBER(4) REFERENCES LOCATIONS(LOCATION_ID)
);
DESC DEPTS;
INSERT INTO DEPTS(DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES(100, NULL, '010.......', 'F', 1700);
INSERT INTO DEPTS(DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES(1, 'HONG', SYSDATE, '010....', 'X', 1700);
INSERT INTO DEPTS(DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES(1, 'HONG', '010....', 'F', 100);
INSERT INTO DEPTS(DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES(2, 'HONG', '010....', 'F', 1700);
INSERT INTO DEPTS(DEPT_NO, DEPT_NAME, DEPT_PHONE, DEPT_GENDER, LOCA_ID)
VALUES(1, 'HONG', '010....', 'F', 1700);

--개체무결성 : 기본키에 NULL이 들어갈 수 없고 중복이 불가
--참조무결성 : PK가 아닌 값이 FK의 값으로 들어갈 수 없음
-- 도메인 무결성 : CHECK나 UNIQUE제약을 위배할 수 없음
-----------------------------------------------------------------------------
--테이블 레벨에서의 제약조건
DROP TABLE DEPTS;
CREATE TABLE DEPTS(
    DEPT_NO NUMBER(2),
    DEPT_NAME VARCHAR2(30) NOT NULL, --NOT NULL의 경우에는 테이블레벨로 지정 못한다.
    DEPT_DATE DATE DEFAULT SYSDATE,
    DEPT_PHONE VARCHAR2(30),
    DEPT_GENDER CHAR(1),
    LOCA_ID NUMBER(4),
    CONSTRAINT DEPTS_DEPT_NO_PN PRIMARY KEY(DEPT_NO), --뒤에 컬럼명을 추가하는 것만 다름
    CONSTRAINT DEPTS_DEPT_PHONE_UK UNIQUE(DEPT_PHONE),
    CONSTRAINT DEPTS_DEPT_GENDER_CK CHECK(DEPT_GENDER IN ('F', 'M')),
    CONSTRAINT DEPTS_LOCA_ID_FK FOREIGN KEY (LOCA_ID) REFERENCES LOCATIONS(LOCATION_ID)
);
--만약 위 테이블레벨 제약조건에서 PRIMARY KET 뒤의 괄호에 컬럼을 여러개 쓰면 슈퍼키 지정하는 것임
--컬럼들이 결합되어 슈퍼키로 작용함
--즉 슈퍼키 지정하려면 테이블레벨로 제약조건 작성해야함.

--이미 존재하는 테이블에 제약조건 추가와 삭제는 가능, 수정은 불가하다.
CREATE TABLE DEPTS(
    DEPT_NO NUMBER(2),
    DEPT_NAME VARCHAR2(30),
    DEPT_DATE DATE DEFAULT SYSDATE,
    DEPT_PHONE VARCHAR2(30),
    DEPT_GENDER CHAR(1),
    LOCA_ID NUMBER(4)
);
ALTER TABLE DEPTS ADD CONSTRAINT DEPTS_DEPT_NO_PK PRIMARY KEY (DEPT_NO);
ALTER TABLE DEPTS MODIFY DEPT_NAME VARCHAR2(30) NOT NULL;
--NOT NULL조건의 경우 MODIFY 구문으로 처리해야 한다.
ALTER TABLE DEPTS ADD CONSTRAINT DEPTS_DEPT_PHONE_UK UNIQUE (DEPT_PHONE);
ALTER TABLE DEPTS ADD CONSTRAINT DEPTS_DEPT_GENDER_CK CHECK (DEPT_GENDER IN ('F', 'M'));
ALTER TABLE DEPTS 
    ADD CONSTRAINT DEPTS_LOCA_ID_FK FOREIGN KEY (LOCA_ID) REFERENCES LOCATIONS(LOCATION_ID);

--삭제하기
ALTER TABLE DEPTS DROP PRIMARY KEY;
ALTER TABLE DEPTS DROP CONSTRAINT DEPTS_LOCA_ID_FK;
--테이블의 제약조건을 SQL문으로 확인
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEPTS'; 


---------------------------------------------------------------------------------
--문제1.
--다음과 같은 테이블을 생성하고 데이터를 insert해보세요.
--테이블 제약조건은 아래와 같습니다. 
--조건) M_NAME 는 가변문자형 20byte, 널값을 허용하지 않음
--조건) M_NUM 은 숫자형 5자리, PRIMARY KEY 이름(mem_memnum_pk) 
--조건) REG_DATE 는 날짜형, 널값을 허용하지 않음, UNIQUE KEY 이름:(mem_regdate_uk)
--조건) SALARY 숫자형 10자리, CHECK제약 (0 보다 크다)
--조건) LOCA 숫자형 4자리, FOREIGN KEY – 참조 locations테이블(location_id) 이름:(mem_loca_loc_locid_fk)
CREATE TABLE MEM (
    M_NAME VARCHAR2(20) NOT NULL,
    M_NUM NUMBER(5) CONSTRAINT MEM_MEMNUM_PK PRIMARY KEY,
    REG_DATE DATE NOT NULL CONSTRAINT MEM_REGDATE_UK UNIQUE,
    SALARY NUMBER(10) CONSTRAINT MEM_SAL_CH CHECK (SALARY>0),
    LOCA NUMBER(4), CONSTRAINT MEM_LOCA_LOC_LOCID_FK FOREIGN KEY (LOCA) REFERENCES LOCATIONS(LOCATION_ID)
);
INSERT INTO MEM VALUES('JAKE', '100', SYSDATE, 1000, 1700);

INSERT INTO MEM VALUES('AAA', '1', '2018-07-01', 5000, 1800);
INSERT INTO MEM VALUES('BBB', '2', '2018-07-02', 3000, 1900);
INSERT INTO MEM VALUES('CCC', '3', '2018-07-03', 3000, 2000);
INSERT INTO MEM VALUES('DDD', '4', SYSDATE, 2000, 2000);
SELECT * FROM MEM;

--문제2.
--도서테이블, 도서 대여 이력 테이블을 생성하려 합니다.
--도서 테이블은
--도서번호(문자) PK, 도서명(문자), 출판사(문자), 입고일(날짜)
CREATE TABLE BOOKS(
    BOOK_NUM VARCHAR2(20) CONSTRAINT BOOKS_BOOK_NUM_PK PRIMARY KEY,
    BOOK_NAME VARCHAR2(40),
    PUBLISHER VARCHAR2(30),
    STOCK_DATE DATE
);

INSERT INTO BOOKS VALUES (1, 'LORD OF THE RINGS', 'GOLDENBOUGH', SYSDATE);

--도서 대여 이력 테이블은
--대여번호(숫자) PK, 도서번호(문자) FK, 대여일(날짜), 반납일(날짜), 반납여부(Y/N)
--를 가집니다.
--적절한 테이블을 생성해 보세요.
CREATE TABLE RENT(
    RENT_NUM NUMBER(10) CONSTRAINT RENT_RENT_NUM_PK PRIMARY KEY,
    BOOK_NUM VARCHAR(20) CONSTRAINT RENT_BOOK_NUM_FK REFERENCES BOOKS(BOOK_NUM),
    RENT_DATE DATE,
    RETURN_DATE DATE,
    RETURNED CHAR(1) CONSTRAINT RENT_RETURNED CHECK (RETURNED IN ('Y', 'N'))
);
INSERT INTO RENT VALUES(1, 1, SYSDATE, SYSDATE+14 ,'N');
SELECT * FROM RENT;