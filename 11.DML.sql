--DML문
--INSERT
DESC DEPARTMENTS;

--1ST. 컬럼을 정확히 일치시키는 경우(모든 컬럼에 값을 넣는 경우)
INSERT INTO DEPARTMENTS VALUES(280, 'DEVELOPER', NULL, 1700);
SELECT * FROM DEPARTMENTS;
--DML문은 항상 트랜잭션을 해줘야 최종 커밋이 됨
ROLLBACK;
SELECT * FROM DEPARTMENTS;
--2ND. 컬럼에 일부 값만 넣는 경우
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID)
        VALUES(280, 'DEVELOPER', 1700);
INSERT INTO DEPARTMENTS (DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
        VALUES(290, 'DBA', 100, 1700);
ROLLBACK;

--서브쿼리로 조회한 데이터도 튜플이니까 그걸 그대로 INSERT문의 VALUES에 넣을 수 있음.
--실습용 더미테이블 생성(아래 쿼리문: EMPS 테이블을 만들지만 값 복제는 하지 않음)
CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES WHERE 1 = 2);
SELECT * FROM EMPS;

INSERT INTO EMPS (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
        (SELECT EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMPLOYEES WHERE JOB_ID LIKE '%PROG');
        
INSERT INTO EMPS (EMPLOYEE_ID, LAST_NAME)
        VALUES ((SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE JOB_ID LIKE '%PRES'), 'HH');
        
-------------------------------------------------------------------------------------
--UPDATE 구문
SELECT * FROM EMPS WHERE EMPLOYEE_ID = 120;
UPDATE EMPS SET FIRST_NAME = 'ANN', SALARY = 3000, COMMISSION_PCT=0.1 WHERE EMPLOYEE_ID = 120;
ROLLBACK;


--UPDATE 서브쿼리
UPDATE EMPS SET (MANAGER_ID, JOB_ID, SALARY)= 
            (SELECT MANAGER_ID, JOB_ID, SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 201)
            WHERE EMPLOYEE_ID = 120;
ROLLBACK;
-------------------------------------------------------------------------------
--DELETE 구문
--삭제 전에 SELECT 로 삭제할 데이터를 꼭 확인할것

INSERT INTO EMPS (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
        (SELECT EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMPLOYEES WHERE JOB_ID LIKE '%MAN');

SELECT * FROM EMPS WHERE EMPLOYEE_ID = 121;
DELETE FROM EMPS WHERE EMPLOYEE_ID = 120;

--DELETE 서브쿼리
DELETE FROM EMPS WHERE JOB_ID = (SELECT JOB_ID FROM EMPS WHERE EMPLOYEE_ID = 121);
SELECT * FROM EMPS;

--모든 데이터가 전부 지워질 수 있는 것은 아님. 
--DEPARTMENTS의 DEPARTMENT_ID는 기본키이고 EMPLOYEES의 DEPARTMENT_ID가 참조하고 있으므로 삭제가 안된다.
SELECT * FROM DEPARTMENTS;
SELECT * FROM EMPLOYEES;
DELETE FROM DEPARTMENTS WHERE DEPARTMENT_ID = 50;
-------------------------------------------------------------------------------
--MERGE문 : 데이터가 있으면 UPDATE, 없으면 INSERT 수행
SELECT * FROM EMPS;

MERGE INTO EMPS E1 --타겟테이블
USING (SELECT * FROM EMPLOYEES WHERE JOB_ID LIKE '%MAN') E2 --병합할 테이블(서브쿼리)
ON (E1.EMPLOYEE_ID = E2.EMPLOYEE_ID) --E1과 E2가 연결되는 조건
WHEN MATCHED THEN 
    UPDATE SET
    E1.SALARY = E2.SALARY,
    E1.COMMISSION_PCT = E2.COMMISSION_PCT
WHEN NOT MATCHED THEN
    INSERT (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
    VALUES (E2.EMPLOYEE_ID, E2.LAST_NAME, E2.EMAIL, E2.HIRE_DATE, E2.JOB_ID);
    
    
--MERGE문으로 직접 특정 데이터에 값을 넣을 수도 있음
MERGE INTO EMPS E1
USING DUAL
ON (E1.EMPLOYEE_ID = 120)
WHEN MATCHED THEN
    UPDATE SET E1.SALARY = 10000,
               E1.HIRE_DATE = SYSDATE
WHEN NOT MATCHED THEN
    INSERT (LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
    VALUES ('E', 'E', SYSDATE, 'E');

--사본 테이블 만들기(연습용)
CREATE TABLE EMP1 AS (SELECT * FROM EMPLOYEES); --통째로 복사하는 경우
SELECT * FROM EMP1;
CREATE TABLE EMP2 AS (SELECT * FROM EMPLOYEES WHERE 1 = 2); --구조만 복사하는 경우
SELECT * FROM EMP2;

DROP TABLE EMP1;
DROP TABLE EMP2;
ROLLBACK;

--------------------------------------------------------------------------------
--연습문제
--문제 1.
--DEPTS테이블을 데이터를 포함해서 생성하세요.
--DEPTS테이블의 다음을 INSERT 하세요.
SELECT * FROM DEPARTMENTS;
DROP TABLE DEPTS;

CREATE TABLE DEPTS AS (SELECT * FROM DEPARTMENTS);
INSERT INTO DEPTS
VALUES (280, '개발', NULL, 1800);
INSERT INTO DEPTS
VALUES (290, '회계부', NULL, 1800);
INSERT INTO DEPTS
VALUES (300, '재정', NULL, 1800);
INSERT INTO DEPTS
VALUES (310, '인사', NULL, 1800);
INSERT INTO DEPTS
VALUES (320, '영업', NULL, 1700);

SELECT * FROM DEPTS;

--문제 2.
--DEPTS테이블의 데이터를 수정합니다
--1. department_name 이 IT Support 인 데이터의 department_name을 IT bank로 변경
UPDATE DEPTS SET DEPARTMENT_NAME  = 'IT_BANK' WHERE DEPARTMENT_NAME = 'IT Support';
--2. department_id가 290인 데이터의 manager_id를 301로 변경
UPDATE DEPTS SET MANAGER_ID = 301 WHERE DEPARTMENT_ID = 290;
--3. department_name이 IT Helpdesk인 데이터의 부서명을 IT Help로 , 매니저아이디를 303으로, 지역아이디를
--1800으로 변경하세요
UPDATE DEPTS SET DEPARTMENT_NAME = 'IT Help'
                , MANAGER_ID = 303
                , LOCATION_ID = 1800
            WHERE DEPARTMENT_NAME = 'IT Helpdesk';
--4. 부서번호 (290, 300, 310, 320) 의 매니저아이디를 301로 한번에 변경하세요.
UPDATE DEPTS SET MANAGER_ID = 301 WHERE DEPARTMENT_ID >280 AND DEPARTMENT_ID <321;


--문제 3.
--삭제의 조건은 항상 primary key로 합니다, 여기서 primary key는 department_id라고 가정합니다.
--1. 부서명 영업부를 삭제 하세요
DELETE FROM DEPTS WHERE DEPARTMENT_NAME = '영업';
--2. 부서명 NOC를 삭제하세요
DELETE FROM DEPTS WHERE DEPARTMENT_NAME = 'NOC';


--문제4
--1. Depts 사본테이블에서 department_id 가 200보다 큰 데이터를 삭제해 보세요.
CREATE TABLE COPY AS (SELECT * FROM DEPTS);
DELETE FROM COPY WHERE DEPARTMENT_ID > 200;
SELECT * FROM COPY;
DROP TABLE COPY;
--2. Depts 사본테이블의 manager_id가 null이 아닌 데이터의 manager_id를 전부 100으로 변경하세요.
CREATE TABLE COPY AS (SELECT * FROM DEPTS);
UPDATE COPY SET MANAGER_ID = 100 WHERE MANAGER_ID IS NOT NULL;
--3. Depts 테이블은 타겟 테이블 입니다.
--4. Departments테이블은 매번 수정이 일어나는 테이블이라고 가정하고 Depts와 비교하여
--일치하는 경우 Depts의 부서명, 매니저ID, 지역ID를 업데이트 하고, 새로유입된 데이터는 그대로 추가해주는 merge문을 작성하세요.
MERGE INTO DEPTS A 
    USING (SELECT DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID FROM DEPARTMENTS) D
    ON (A.DEPARTMENT_ID = D.DEPARTMENT_ID)
WHEN MATCHED THEN
    UPDATE SET
    A.DEPARTMENT_NAME = D.DEPARTMENT_NAME,
    A.MANAGER_ID = D.MANAGER_ID,
    A.LOCATION_ID = D.LOCATION_ID
WHEN NOT MATCHED THEN
    INSERT VALUES (D.DEPARTMENT_ID, D.DEPARTMENT_NAME, D.MANAGER_ID, D.LOCATION_ID);
SELECT * FROM DEPTS;    


--문제 5
SELECT * FROM JOBS;
--1. jobs_it 사본 테이블을 생성하세요 (조건은 min_salary가 6000보다 큰 데이터만 복사합니다)
CREATE TABLE JOBS_IT AS (SELECT * FROM JOBS WHERE MIN_SALARY > 6000);
SELECT * FROM JOBS_IT;
--2. jobs_it 테이블에 아래 데이터를 추가하세요
INSERT INTO JOBS_IT VALUES('IT_DEV', '아이티개발팀', 6000, 20000);
INSERT INTO JOBS_IT VALUES('NET_DEV', '네트워크개발팀', 5000, 20000);
INSERT INTO JOBS_IT VALUES('SEC_DEV', '보안개발팀', 6000, 19000);
--3. Jobs_it은 타겟 테이블 입니다
--jobs테이블은 매번 수정이 일어나는 테이블이라고 가정하고 jobs_it과 비교하여
--min_salary컬럼이 0보다 큰 경우 기존의 데이터는 min_salary, max_salary를 업데이트 하고 새로 유입된
--데이터는 그대로 추가해주는 merge문을 작성하세요.
MERGE INTO JOBS_IT A
USING (SELECT * FROM JOBS WHERE MIN_SALARY > 0) B
ON (A.JOB_ID = B.JOB_ID)
WHEN MATCHED THEN
    UPDATE SET A.MIN_SALARY = B.MIN_SALARY,
                A.MAX_SALARY = B.MAX_SALARY
WHEN NOT MATCHED THEN
    INSERT VALUES (B.JOB_ID, B.JOB_TITLE, B.MIN_SALARY, B.MAX_SALARY);
    
SELECT * FROM JOBS_IT;